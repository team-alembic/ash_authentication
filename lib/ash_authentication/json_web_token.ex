defmodule AshAuthentication.JsonWebToken do
  use Joken.Config, default_signer: nil
  alias Ash.Resource
  alias Joken.Signer
  import AshAuthentication.Utils, only: [to_sentence: 2]

  @default_algorithm "HS256"
  @default_lifetime_hrs 7 * 24

  @moduledoc """
  Uses the excellent `joken` hex package to generate and sign JWTs.

  ## Configuration

  This module is configured in your Application environment:

  ```elixir
  config :ash_authentication, #{inspect(__MODULE__)},
    signing_algorithm: #{inspect(@default_algorithm)},
    signing_secret: "I finally invent something that works!",
    token_lifetime: #{@default_lifetime_hrs} # #{@default_lifetime_hrs / 24.0} days
  ```

  Available signing algorithms are #{to_sentence(Signer.algorithms(), final: "or")}.  Defaults to #{@default_algorithm}.

  We strongly advise against storing the signing secret in your mix config.  We
  instead suggest you make use of
  [`runtime.exs](https://elixir-lang.org/getting-started/mix-otp/config-and-releases.html#configuration)
  and read it from the system environment or other secret store.

  The default token lifetime is #{@default_lifetime_hrs} and should be specified
  in integer positive hours.

  This module contains a number of public functions [as generated by
  `Joken.Config`](https://hexdocs.pm/joken/Joken.Config.html#functions) however
  you are unlikely to need to use them directly, and should instead rely on the
  `AshAuthentication` actions to provide signed tokens where needed.
  """

  @doc false
  @impl Joken.Config
  @spec token_config :: Joken.token_config()
  def token_config(config \\ config()) do
    default_claims(default_exp: token_lifetime(config))
    |> add_claim("iss", &issuer_generator/0, &issuer_validator/3)
    |> add_claim("aud", &audience_generator/0, &audience_validator/3)
  end

  @doc """
  Returns a `Joken.Signer` correctly configured based on the system-wide configuration.
  """
  @spec token_signer :: Joken.Signer.t()
  def token_signer(config \\ config()) do
    algorithm = Keyword.get(config, :signing_algorithm, @default_algorithm)

    case Keyword.fetch(config, :signing_secret) do
      {:ok, secret} ->
        Signer.create(algorithm, secret)

      :error ->
        raise "Missing JWT signing secret. Please see the documentation for `AshAuthentication.JsonWebToken` for details"
    end
  end

  @doc """
  Returns the configured token lifetime in seconds.
  """
  @spec token_lifetime :: seconds :: non_neg_integer()
  def token_lifetime(config \\ config()) do
    hours = Keyword.get(config, :token_lifetime, @default_lifetime_hrs)
    hours * 60 * 60
  end

  @doc """
  The generator function used to generate the "iss" claim.
  """
  @spec issuer_generator :: String.t()
  def issuer_generator(vsn \\ version()) do
    "AshAuthentication v#{vsn}"
  end

  @doc """
  The validation function used to validate the "iss" claim.

  It simply verifies that the claim starts with `"AshAuthentication"`
  """
  @spec issuer_validator(String.t(), any, any) :: boolean
  def issuer_validator(claim, _, _), do: String.starts_with?(claim, "AshAuthentication")

  @doc """
  The generator function used to generate the "aud" claim.

  It generates an Elixir-style `~>` version requirement against the current
  major and minor version numbers of AshAuthentication.
  """
  @spec audience_generator :: String.t()
  def audience_generator(vsn \\ version()) do
    "~> #{vsn.major}.#{vsn.minor}"
  end

  @doc """
  The validation function used to validate the "aud" claim.

  Uses `Version.match?/2` to validate the provided claim against the current
  version.  The use of `~>` means that tokens generated by versions of
  AshAuthentication with the the same major version and at least the same minor
  version should be compatible.
  """
  @spec audience_validator(String.t(), any, any) :: boolean
  def audience_validator(claim, _, _, vsn \\ version()) do
    Version.match?(vsn, Version.parse_requirement!(claim))
  end

  @doc """
  Given a record, and an API generate a signed JWT for use while authenticating.
  """
  @spec token_for_record(Resource.record()) ::
          {:ok, String.t(), %{required(String.t()) => String.t()}}
  def token_for_record(record) do
    subject = AshAuthentication.resource_to_subject(record)
    claims = %{"sub" => subject}

    claims =
      case Map.get(record.__metadata__, :tenant) do
        nil -> claims
        tenant -> Map.put(claims, "tenant", to_string(tenant))
      end

    generate_and_sign(claims, token_signer())
  end

  defp version do
    {:ok, vsn} = :application.get_key(:ash_authentication, :vsn)

    vsn
    |> to_string()
    |> Version.parse!()
  end

  defp config do
    :ash_authentication
    |> Application.get_env(__MODULE__, [])
  end
end
